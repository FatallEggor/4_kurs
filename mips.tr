.so 2syktsu.tmac
.\"nr HI 3*\n[PI]
.ds M \(Fo
.ds U \(Fc
.ds DS "дата, подпись
.ds - \(em
.ds _ \(en
.ds FGCAPBG Рисунок
.ds FGCAPSM рис.
.ds FGNRSEP \(em
.char \[star] "\v'-0.2m'\(**\v'0.2m'"
.
.
.TC
.sp 13v
.PP
\s+2\fBОпределения, обозначения и сокращения\fP\s0
.PP
В настоящей работе применяются следующие сокращения с соответсвующими расшифровками: 
.PP
1.  \fBЛЭ\fP \(em логические элементы.
.PP
2.  \fBЗИ\fP \(em защита информации.
.PP
3.  \fBПЛИС\fP \(em программируемые логические интегральные схемы.
.PP
4.  \fBЦПУ\fP \(em центральное процессорное устройство.
.PP
5.  \fBHDL\fP \(em hardware describe language.
.PP
6.  \fBПО\fP \(em программное обеспечение.
.PP
7.  \fBPLA\fP \(em programmable logic array.
.PP
8.  \fBRISC\fP \(em reduced instruction set computer.
.PP
9.  \fBCISC\fP \(em complex instruction set computer.
.PP
10.  \fBВКР\fP \(em Выпускная квалификационная работа.
.PP
.PP
В настоящей работе применяются следующие термины с соответствующими определениями:
.PP
1.  \fBАрхитектура ЦПУ\fP\(em набор типов данных, операций и регистров, доступных для программирования.
.PP
2.  \fBМикроархитектура ЦПУ\fP \(em способ, которым данная архитектура реализована в процессоре.  
.PP
.
.
.U1 "ВВЕДЕНИЕ"
.PP
Опутывание мира сетью коммуникаций, стремительное расширение
применения мобильных и облачных сервисов, 
а так же соц. сетей приводит к тому, 
что список угроз безопасности передачи данных продолжает расти.
В него постоянно добавляются новые способы взлома, мошенничества, 
новые вредоносные программы, новые типы вирусов, 
новые способы перехвата данных. 
Такое бурное развитие угроз, в свою очередь, 
стимулирует массовое применение средств защиты.
Самым распространённым средством защиты передаи данных является криптографический метод.  
.PP
Криптографические Методы Защиты Информации (КМЗИ)
серьёзно повышают защищённость данных, однако,
требуют большого количества дополнительных вычислений, 
нагружающих аппаратуру.
Помимо того, стандартные микропроцессорные устройства имеют общий, 
неспециализированный набор команд, 
использование которых снижает скорость обработки данных. 
.PP
В данных условиях было решено разработать свой вариант аппаратного средства защиты информации (ЗИ) на основе программируемых логических интегральных схем(ПЛИС).
Данная задача слишком велика для выполнения её в рамках курсовой работы, 
поэтому было принято решение рaзбить её на подзадачи, 
часть из которых выполнить в рамках данной курсовой работы, а оставшиеси \(em 
в рамках выпускной квалификационной работы (ВКР).
.PP
Актуальность данной работы определяется увеличением потоков информации в условиях постепенного снижения скорости развития аппаратных мощностей современных систем.
Перемещние криптографической обработки данных в отдельные аппаратные блоки является одним из вариантов решения сложившейся ситуации.
Ускоренная аппаратная криптографическая обработка вместо программного выполнения этих же алгоритмов позволяет разгрузить центральный процессор для выполнения других операций. 
Некоторые производители уже имеют наработки в данной области.
Реализация данных технологий, однако, носит закрый пропреитарный характер.
Данные технологии не имеют широкого распространения.
В рамках работы будет произведена попытка расширить применяемость данной технологии посредством создания открытого аналога данной технологии и 
описания её на языке Verilog. 
.PP
Объектом исследования курсовой работы является процесс создания процессорного ядра на основе ПЛИС и создание на его основе аппаратного средства ЗИ. 
.PP
Предметами исследования являютс применимость ПЛИС для решения задач ЗИ и способы построения  аппаратных средств ЗИ на основе процессоров.
.PP
Целью курсовой работы является создание процессорного ядра на основе ПЛИС для дальнейшего использования его в качестве платформы для аппаратного средства ЗИ. 
.PP
\*BПостановка задачи\*P
.PP
Для достижения поставленной цели необходимо решить следующие задачи:
.RS
.PI \(bu
Рассмотреть применимость ПЛИС и Hardware Description Language (HDL)
для задач ЗИ.
.PI \(bu
Изучить процессорную архитектуру MIPS.
.PI \(bu
Рассмотреть способы построения  аппаратных средств ЗИ на основе процессоров.
.PI \(bu
Создать ядро ЦПУ, на основе которого и будет выполняться средство ЗИ.
.
.RE
.PP
\*BВыбор метода реализации задач:\*P
.PP
Основной задачей данной работы является создание ядра ЦПУ, 
на основе которого и будет выполняться средство ЗИ.
В качестве базовой архитектуры процессора выбрана архитектура MIPS.
Инструментами для решения основной задачи были выбраны 
язык описания аппаратуры Verilog и 
тестовая ПЛИС Xilinx Spartan-3AN FPGA Starter Kit Board.
.
.
.
.H1 "ПЛИС И HDL. ПРИМЕНИМОСТЬ ДЛЯ РЕШЕНИЯ ЗАДАЧ ЗИ"
.
.H2 "Метод абстракций"
.PP
Проектирование сложных систем невозможно без использования различного рода абстракций.
Абстракция подразумевает исключение из рассмотрения тех элементов, 
которые в данном случае несущественны для понимания работы системы.
.PP
Современная электронная система состоит из
полупроводниковых устройств, таких как транзисторы.
Любое электронное устройство может быть представлено абстрактной математической моделью, 
описывающей изменяющуюся во времени взаимозависимость тока и напряжения.
.PP
Следующий уровень абстракции \(em это аналоговые схемы,
в которых полупроводниковые устройства соединены таким образом, 
чтобы они образовывали функциональные компоненты, такие как усилители, например. 
Напряжение на входе и на выходе аналоговой цепи изменяется в непрерывном диапазоне.
.PP
В отличие от аналоговых цепей, цифровые схемы, 
такие как логические вентили, используют два строго ограниченных дискретных уровня напряжения. 
Один из этих дискретных уровней \(em это логический нуль, 
другой \(em логическая единица.
Связывая вместе логические элементы мы создаём микроархитектуру.
.PP
Микроархитектурный уровень абстракции, или просто
микроархитектура, связывает логический и архитектурный уровни абстракции. 
Архитектурный уровень абстракции, или архитектура, 
описывает компьютер с точки зрения программиста.
.PP
Наконец, сегодняшние пользователи общаются с уровнем программного обеспечения (ПО).
Операционная система (ОС) управляет операциями нижнего уровня, 
такими как доступ к жесткому диску или управление памятью. 
И, наконец, программное обеспечение использует ресурсы 
операционной системы для решения конкретных задач пользователя.
.PP
Даннаая работа подразумевает общение с тремя уровнями абстракции: 
.RS
.PI \(bu
уровнем цифровых схем,
.PI \(bu
микроархитектурным уровнем,
.PI \(bu
архитектурным уровнем,
.RE
На данных уровнях абстракции самыми удобными инструментами работы являются языки описания аппаратуры и ПЛИС[1].
.PP
.H2 "ПЛИС"
На сегодняшний день при проектировании цифровых устройств никто не использует 
дискретные элементы. 
Данный подход трудозатратен, дорогостоящ и неэффективен.
Вместо этого применяют матрицы логических элементов.
Такие матрицы состоят из наборов логических элементов, 
соединения которых можно сконфигурировать для реализации произвольной логической функции, 
при этом не надо будет изменять соединения между микросхемами на плате.
Регулярная структура упрощает проектирование. 
Матрицы логических элементов производятся в больших количествах, 
что обеспечивает их малую стоимость.
Существует программное обеспечение, 
позволяющее перенести проекты цифровых устройств в такие матрицы. 
Большинство матриц логических элементов реконфигурируемо, 
что позволяет изменить проект без замены аппаратного обеспечения. 
Реконфигурируемость очень ценна при разработке и полезна при эксплуатации 
изделия,
поскольку оно может быть обновлено путём простой загрузки новой конфигурации.
.PP
В основном, сегодня используются два типа матриц логических элементов: 
.RS
.PI \(bu
PLA (Programmable Logic Array) или ПЛМ (программируемая логическая матрица)
\(em  программируемый массив (матрица) логических элементов. 
.PI \(bu
FPGA (field-programmable gate array) или 
ПЛИС (программируемая логическая интегральная схема)
\(em программируемая \*Bпользователем\*P матрица логических 
\*Bреконфигурируемых\*P элементов.
.RE
.PP
PLA  остаются более дешёвым решением, однако,
ввиду ограниченности функциональности, а так же невозможности реконфигурирования, PLA постепенно вытесняются FPGA[2].  
.PP
\*BПрограммируемые логические интегральные Схемы\*P
.LQ fig:fpga
.PP
ПЛИС представляет собой матрицу конфигурируемых логических элементов, 
которые также называются конфигурируемыми логическими блоками. 
Каждый ЛЭ можно сконфигурировать для выполнения
функций некoторой комбинационной или последовательной схемы.
На Рисунке\*(LT  приведена обобщённая структура ПЛИС. 
ЛЭ окружены элементами ввода/вывода, 
которые предназначены для организации обмена информацией между FPGA и
прочими компонентами системы. 
Элементы ввода/вывода соединяют входы и выходы логических элементов с 
контактами корпуса микросхемы. 
Логические элементы могут быть соединены между собой
и с элементами ввода/вывода с помощью программируемых каналов трассировки[2].
.FG images/FPGA.eps fig:fpga "Пример структуры ПЛИС"
.
.H2 "HDL"
.PP
В 1990-е годы разработчики обнаружили, 
что их производительность труда резко возрастала, 
если они работали на более высоком уровне абстракции,
определяя только логическую функцию и предоставляя создание
оптимизированных логических элементов системе автоматического
проектирования (САПР). 
Для этой цели стали использовать языки описания аппаратуры или Hardware Description Language (HDL). 
Два основных языка описания аппаратуры \(em Verilog и VHDL.
Verilog и VHDL построены на похожих принципах, 
но их синтаксис весьма различается.
На обоих языках можно полностью описать любую электронную
систему.
Две основные цели HDL \(em логическая симуляция и синтез[1].
.PP
Симуляция предназанчена для снижения затрат на тестирование системы.
Тестирование системы в лаборатории весьма трудоёмко. 
Исследовать причины ошибок в лаборатории может быть очень сложно,
так как наблюдать можно только сигналы, подключенные к контактам чипа,
а то, что происходит внутри чипа, напрямую наблюдать невозможно.
Исправление ошибок уже после того, как система была выпущена,
может быть очень дорого. 
Например, исправление одной ошибки в новейших интегральных микросхемах
стоит больше миллиона долларов и занимает несколько месяцев.
.PP
Во время симуляции на входы модуля подаются некоторые воздействия и
проверяются выходы, чтобы убедиться, что модуль функционирует
корректно. 
.PP
Логический синтез преобразует код на HDL в нетлист, описывающий
цифровую аппаратуру (т.е. логические элементы и соединяющие их
проводники). Логический синтезатор может выполнять оптимизацию
для сокращения количества необходимых элементов. Нетлист может
быть текстовым файлом или нарисован в виде схемы, чтобы было
легче визуализировать систему.
.PP
В конце концов, нетлист можно преобразовать в бинарную прошивку и
загрузить её на ПЛИС.
.
.H2 "Применимость для решения задач ЗИ"
.PP
Можно выделить следующие важные для ЗИ особенности ПЛИС и HDL:
.RS
.PI 1.
ПЛИС очень гибки в настройке, что позволяет использовать их 
для решения многих задач, в том числе, необычных. 
.PI 2.
При исчезновении угрозы или её изменении, ПЛИС можно реконфигурировать, 
чтобы испоьзовать для других возможных нужд.
.PI 3.
Реконфигурацию ПЛИС  можно произвести втечение очень малого времени, 
не приостанавливая деятельность надолго, 
так как используется достаточно высокий уровень абстракции в виде HDL. 
.PI 4.
Так как VHDL и Verilog являются стандартизованными языками, 
проекты, описанные на этих языках являются кроссплатформенными.
.PI 5.
Современные ПЛИС оснащаются встроенными оптимизированными модулями,
выполняющими различные функции, 
что делает их ещё более простыми и привлекательными для 
построения систем сложных вычислений.
.PI 6.
На данный момент ПЛИС являются доступным, 
изящным и относительно недорогим решением широкого круга проблем.
.RE
.PP
На основании вышеизложенных преимуществ, можно сделать вывод о том, 
что ПЛИС и HDL являются мощными инструментами для 
решения широкого круга задач и в частности, задач ЗИ.
.
.H1 "АРХИТЕКТУРА MIPS"
.PP
В качестве основы в данной работе используется архитектура MIPS.  
Архитектура MIPS является простой reduced instruction set computer (RISC) архитектурой. 
В последующих главах будут рассмотрены основные особенности архитектуры MIPS, такие как:
.RS
.PI \(bu
Форматы инструкций;
.PI \(bu
Режимы адресации;
.PI \(bu
Карта памяти;
.RE
.H2 "Инструкции"
В архитектуре MIPS в качестве компромисса между простотой и
универсальностью используются три формата инструкций: 
типа R, типа I и типа J.
Небольшое количество форматов обеспечивает определенное
единообразие между всеми тремя типами и, как следствие, 
более простую аппаратную реализацию. 
При этом разные форматы позволяют учитывать 
различные потребности инструкций, как, например, 
необходимость хранить большие константы внутри инструкций.
.H3 "Инструкции типа R"
Название типа R является сокращением от "Register-type" \(em регистрового типа 
Инструкции типа R используют три регистра в качестве операндов: 
два регистра-источника и один регистр-назначение.
На Рисунке 2 показан машинный формат команды типа R. 32-битная
команда состоит из шести полей: \f(CWop, rs, rt, rd, shamt\fP и \f(CWfunct\fP.
Каждое поле состоит из пяти или шести бит[1].
.PS
bitsize = 4 / 32;
op = 6 * bitsize;
rs = 5 * bitsize;
rt = rs;
rd = rs;
shamt = 5 * bitsize;
funct = 6 * bitsize;
move 1.35;
[box width op "op";box  width rs "rs";box width rt "rt";box width rd "rd";box width shamt "shamt";box width funct "funct";
"6 bits" at 6th last  box .s + (0, -0.15); 
"5 bits" at 5th last  box .s + (0, -0.15); 
"5 bits" at 4th last  box .s + (0, -0.15); 
"5 bits" at 3th last  box .s + (0, -0.15); 
"5 bits" at 2th last  box .s + (0, -0.15); 
"6 bits" at 1th last  box .s + (0, -0.15);]
move to last [].s + (0, -0.25);
"Рисунок 2 \(em Rtype"
.PE
.PP
Операция, выполняемая командой, закодирована двумя полями: 
полем \f(CWop\fP (также называемым \f(CWopcode\fP или
кодом операции) и полем \f(CWfunc\fP (также называемым функцией). 
У всех команд типа R поле \f(CWopcode\fP равно нулю. 
Операция, выполняемая этими командами, 
определяется исключительно полем \f(CWfunct\fP. 
Например, поля \f(CWopcode\fP и \f(CWfunct\fP у инструкции \f(CWadd\fP
равны 0 и 32 соответственно.
Аналогично, у команды \f(CWfsub\fP поля \f(CWopcode\fP
и \f(CWfunct\fP равны 0 и 34.
.PP
Операнды закодированы тремя полями: \f(CWrs, rt\fP и \f(CWrd \fP. 
Поля содержат
номера регистров.
Пятое поле, \f(CWshamt\fP, является сокращением от shift amount
используется только для операций сдвига.
В таких командах двоичное значение, хранимое в 5-битном поле
\f(CWshamt\fP, задаёт величину сдвига. 
У всех остальных команд типа R поле  \f(CWshamt\fP равно 0.
.H3 "Инструкции типа I"
Название типа I является сокращением от immediate-type или 
непосредственного типа. 
Инструкции типа I используют в качестве операндов два регистра и 
один непосредственный операнд (константу).
.PP
На Рисунке 3 показан формат машинной команды типа I. 32-битная
команда состоит из четырёх полей: \f(CWop, rs, rt\fP и \f(CWimm\fP. 
Первые три поля \f(CW(op, rs\fP и \f(CWrt)\fP аналогичны таким же полям в командах типа R. 
Поле \f(CWimm\fP (сокр. от immediate) содержит 16-битную константу.
16-битные константы перед использованием в операциях 
будут расширены до 32 бит посредством знакового расширения 
либо дополнения нулями[1].
.PS
bitsize = 4 / 32;
op = 6 * bitsize;
rs = 5 * bitsize;
rt = rs;
rd = rs;
imm = 16 * bitsize;
move 1.35;
[box width op "op"; ;box  width rs "rs";box width rt "rt";box width imm  "imm";
"6 bits" at 4th last  box .s + (0, -0.15); 
"5 bits" at 3th last  box .s + (0, -0.15); 
"5 bits" at 2th last  box .s + (0, -0.15); 
"16 bits" at 1th last  box .s + (0, -0.15);] 
move to last [].s + (0, -0.25);
"Рисунок 3 \(em Itype"
.PE
.PP
Операция определяется исключительно полем \f(CWopcode\fP. 
Операнды заданы в трёх полях: 
\f(CWrs, rt \fPи \f(CWimm. \fPПоля \f(CWrs\fP и
imm всегда используются как операнды-источники. 
Поле \f(CWrt\fP в некоторых командах (например, \f(CWaddi\fP и \f(CWlw\fP) содержит номер регистра-назначения,
в других (например, \f(CWsw\fP) \(em номер регистра-источника.
.H3 "Инструкции типа J"
.PP
Название типа J является сокращением от английского слова jump \(em прыжок.
Этот формат используется только для инструкций безусловного перехода и ветвления.
Как и другие команды, команды типа J начинаются с 6-битного поля
кода операции  \f(CWopcode\fP.
Также, этот формат инструкций содержит 26-битный операнд \f(CWaddr\fP.
Константное значение \f(CWaddr\fP используется для указания адреса перехода[1].
.PS
bitsize = 4 / 32;
op = 6 * bitsize;
addr = 26 * bitsize;
move 1.35;
[box width op "op"; ;box width addr  "addr";
"6 bits" at 2th last  box .s + (0, -0.15); 
"26 bits" at 1th last  box .s + (0, -0.15);] 
move to last [].s + (0, -0.25);
"Рисунок 4 \(em Jtype"
.PE
.H2 "Режимы адресации"
В архитектуре MIPS используются пять режимов адресации:
регистровый, непосредственный, базовый, относительно счетчика команд
и псевдопрямой. Первые три режима (регистровый, непосредственный и базовый) 
определяют способы чтения и записи операндов. 
Последние два (режим адресации относительно счетчика команд и 
псевдопрямой режим) определяют способы записи счётчика команд[1].
.H3 "Регистровая адресация"
.PP
При регистровой адресации регистры используются для всех
операндов-источников и операндов-назначений 
(иными словами \(em для всех операндов и результата). 
Все инструкции типа R используют именно такой режим адресации[1].
.H3 "Непосредственная адресация"
.PP
При непосредственной адресации в качестве операндов наряду с
регистрами используют 16-битные константы (непосредственные операнды). 
Этот режим адресации используют некоторые инструкции типа I, 
такие как сложение с константой \f(CW(addi)\fP и загрузка константы в
старшие 16 бит регистра \f(CW(lui)\fP[1].
.H3 "Базовая адресация"
.PP
Инструкции для доступа в память, такие как загрузка слова \f(CW(lw)\fP и
сохранение слова \f(CW(sw)\fP, используют базовую адресацию. 
Эффективный адрес операнда в памяти вычисляется путём сложения базового 
адреса в регистре \f(CWrs\fP и 16-битного смещения с расширенным знаком,
являющегося непосредственным операндом[1].
.H3 "Адресация относительно счётчика команд"
.PP
Инструкции условного перехода, или ветвления, 
используют адресацию относительно счётчика команд 
для определения нового значения счётчика команд в том случае, 
если нужно осуществить переход.
Смещение со знаком прибавляется к счётчику команд (PC) для определения 
нового значения PC, поэтому тот адрес, куда будет осуществлен переход,
называют адресом относительно счётчика команд[1].
.H3 "Псевдопрямая адресация"
.PP
При прямой адресации адрес перехода задаётся внутри инструкции.
Инструкции безусловного перехода \f(CWj\fP и \f(CWjal\fP в идеале могли бы
использовать прямую адресацию для определения 32-битного
целевого адреса перехода, указывающего адрес инструкции, 
которая будет выполнена следующей.
К сожалению, в формате инструкций типа J нет достаточного
количества бит для того, чтобы задать полный 32-битный адрес перехода.
Шесть старших бит инструкции занимает код операции (поле \f(CWopcode)\fP, 
поэтому для адреса перехода остаётся только 26 бит.
К счастью, два младших бита адреса перехода всегда должны быть равны нулю,
потому что все инструкции выровнены по словам.
Следующие 26 бит адреса перехода берутся из поля \f(CWaddr \fPинструкции. 
Четыре старших бита адреса перехода берутся из 
четырёх старших бит значения \f(CW PC + 4\fP. 
Такой способ адресации называется псевдопрямым[1].
.H2 "Карта памяти"
.PP
Так как архитектура MIPS использует 32-битные адреса, 
то размер адресного пространства составляет 4 гигабайта.
Адреса слов кратны 4 и располагаются в промежутке от
0 до 0xFFFFFFFC. На Рисунке 5 изображена карта памяти MIPS.
Адресное пространство разделено на четыре части, или сегмента:
сегмент кода, сегмент глобальных данных, сегмент динамических
данных и зарезервированный сегмент. 
Эти сегменты рассматриваются в следующих разделах.
.PS
move 1.7
["Адрес";
move 1.5;
"Сегменты";move down 0.2;
box width 1.6 height 1 fill 0.3 "Зарезервированый";
box width 1.6 height 1 "Динамических данных";
box width 1.6 height 0.5 "Глобальных данных";
box width 1.6 height 0.5 "Кода";
box width 1.6 height 0.5 fill 0.3 "Зарезервированный";
"0xFFFFFFFC" at 1st "" .s + (0, -0.25);
"0x80000000" at 1st "" .s + (0, -1.15);
"0x7FFFFFFC" at 1st "" .s + (0, -1.35);
"0x10010000" at 1st "" .s + (0, -2.15);
"0x1000FFFC" at 1st "" .s + (0, -2.35);
"0x10000000" at 1st "" .s + (0, -2.65);
"0x0FFFFFFC" at 1st "" .s + (0, -2.85);
"0x00400000" at 1st "" .s + (0, -3.15);
"0x003FFFFC" at 1st "" .s + (0, -3.35);
"0x00000000" at 1st "" .s + (0, -3.65);
"$sp = 0x7FFFFFFC" at 2nd box .ne + (1.1, -0.1);
arrow from last "" .w + (-0.7, 0) to 2nd box .ne + (0,-0.1);
"$gp = 0x10008000" at 3rd box .ne + (1.1, -0.1);
arrow from last "" .w + (-0.7, 0) to 3rd box .ne + (0,-0.1);
"$PC = 0x00400000" at 4th box .se + (1.1, 0.1);
arrow from last "" .w + (-0.7, 0) to 4th box .se + (0,0.1);]
move to last [].s + (0, -0.25);
"Рисунок 5 \(em Карта памяти MIPS"
.PE
.H3 "Сегмент кода"
.PP
Сегмент кода (text segment) содержит машинные команды исполняемой программы. 
Его размер достаточен для размещения почти 256 Мбайт кода. 
Четыре старших бита адреса в сегменте кода всегда равны нулю, 
что позволяет использовать инструкцию \f(CWj\fP для перехода по любому адресу в программе[1].
.H3 "Сегмент глобальных данных"
.PP
Сегмент глобальных данных (global data segment) содержит 
глобальные переменные, которые, в отличие от локальных переменных,
находятся в области видимости всех функций программы. 
Глобальные переменные инициализируются при загрузке программы, но до начала
её выполнения[1].
.PP
Доступ к глобальным переменным осуществляется при помощи
глобального указателя \f(CW(gp)\fP, который инициализируется значением 0x100080000.
Любая глобальная переменная доступна при помощи 16-битного 
положительного или отрицательного смещения относительно \f(CWgp\fP.
.H3 "Сегмент динамических данных"
.PP
Сегмент динамических данных содержит стек и кучу. 
В момент запуска программы этот сегмент не содержит данных \(em 
они динамически выделяются и освобождаются в нём в 
процессе выполнения программы. 
Сегмент динамических данных \(em это самый большой сегмент памяти,
в карте памяти архитектуры MIPS \(em его размер составляет почти 2 Гбайт.
.PP
Стек используется для сохранения и восстановления регистров, 
используемых функциями, а также хранения локальных переменных, 
таких как массивы. 
Стек растёт вниз от верхней границы сегмента динамических данных (0x7FFFFFFC), а доступ к кадрам стека осуществляется в режиме очереди LIFO.
.PP
Куча используетя для хранения блоков памяти, 
динамически выделяемых программе во время работы.
.H3 "Зарезервированный сегмент"
.PP
Зарезервированный сегмент выделяется для нужд операционной системой.
В частности, зарезервированная память используется для программных прерываний 
и для отображения устройств ввода-вывода в адресное пространство.
.H2 "Итог"
.PP
Подводя итоги вышеорисанных особенностей, можно сказать, 
что архитектура MIPS имеет понятный, единообразный и простой, 
но  достаточный для выполнения поставленной задачи формат инструкций.
Результатом описанных особенностей является простая аппаратная реализация.
Простота реализации стала определяющим фактором при выборе архитектуры.
.
.
.
.H1 "МЕТОДЫ РЕАЛИЗАЦИИ И ПРИМЕНЕНИЯ СРЕДСТВА ЗИ"
.
.H2 "Методы реализации"
.PP
Конечной целью является создание аппаратного средства ЗИ криптографическими методами на основе
микропроцессора с MIPS-подобной архитектурой с помощью ПЛИС и HDL.
.PP
Данная цель может быть реализована двумя способами:
.RS
.PI 1.
Посредством расширения встроенного тракта данных ядра;
.PI 2.
Посредством создания специализированного сопроцессора для 
выполнения криптографических функций.
.RE
.
.
.H3 "Расширение встроенного тракта данных ядра"
.PP
Стандартный миркопроцессор содержит общий,
неспециализированный набор инструкций. 
Написание криптографических алгоритмов с помощью 
стандартного набора инструкций может стать очень трудоёмкой задачей.
Объём программного кода при использовании только стандартного набора команд
становится очень большим при написании сложных алгоритмов, 
время выполнения таких алгоритмов тоже становится большим.
.PP
Стандартный набор инструкций можно расширить. 
Такие системы называются системами с расширенным набором команд или 
Complex Instruction Ser Computer(CISC).
Расширение набора команд можно совершить посредством 
добавления дополнительных модулей в тракт данных ядра процессора.
Эти модули могут быть специализированы для выполнения строго 
определённых функций.
.PP
В представленном случае это могут быть функции, 
часто используемые в криптографических алгоритмах, 
такие как:
.RS
.PI \(bu
Логические операции, как XOR, XNOR, NOR и т.д;
.PI \(bu
Операции над конечными полями;
.PI \(bu
Перестановки бит или байт в блоке;
.PI \(bu
Расширение блока
.PI \(bu
и др.
.PP
Главная особенность данного метода состоит в том, 
что модули расширения не выходят за границы ядра, 
то есть не являются отдельными устройствами. 
.RE
.H3 "Создание сопроцессора"
.PP
Сопроцессор \(em специализированный процессор, 
расширяющий возможности центрального процессора компьютерной системы,
но оформленный как отдельный функциональный модуль. 
Физически сопроцессор может быть отдельной микросхемой или 
может быть встроен в центральный процессор.
.PP
Сопроцессор расширяет базовый набор инструкций и регистров ЦПУ.
ЦПУ и его сопроцессор соединяются общей системной шиной данных, 
сигнальной шиной, шиной флагов,и т.д. в набор инструкций ЦПУ могут быть встроены 
специальные инструкции обмена данными с сопроцессором.
.PP
Декодирование и выполнение инструкций может проходить по одному 
из следующих сценариев:
.RS
.PI 1.
ЦПУ декодирует инструкцию и отправит соответствующую команду 
сопроцессору на выполнение вместе с сопутствующими данными.
Сопроцессор декодирует команду и начнёт выполнение.
Данные могут как передаваться в регистры сопроцессора,
так и оставаться в регистрах ЦПУ, в таком случае сопроцессору будут переданы
лишь номера регистров, в которых находятся данные.
.PI 2.
При возникновении новой инструкции на системной шине, 
она может быть декодирована и ЦПУ и сопроцессором одновременно.
Если инструкция является инструкцией сопроцессора,
ЦПУ сразу приступает к передаче соответствующих операндов,
а сопроцессор \(em к выполнению инструкции.
.RE
.PP
Во время выполнения инструкций сопроцессор и ЦПУ обмениваются управляющими
сигналами посредством соответствующих флагов, так, например, на время выполнения может быть выставлен флаг \f(CWbusy\fP, 
а на случай прерываний может быть выставлен флаг   \f(CWinterrupt\fP[2].
.PP
Сопроцессор может выполнять как отдельные операции, 
присущие криптоалгоритмам, так и полностью выполнять криптоалгоритмы.
Важно так же отметить, что у одного ЦПУ может быть и 
несколько сопроцессоров, каждый из которых может быть специализирован на 
выполнение отдельного набора инструкций, 
или же их наборы инструкций могут пересекаться.
В таком случае вводится ещё один вид управляющего сигнала \f(CWselect\fP.
Общая картина соединения ЦПУ и сопроцессоров показана на Рисунке 6.
.
\#hack with .KS | .KE
.
.KS
.PS
move 0.8;
#upper buses
L1: line 4 "Системная шина данных""";
move to L1.s + (0, -0.3);
L2: line 4 "Шина адреса""";
move to L2.s + (0, -0.8);
#boxes
B1: box wid 1 ht 1 "ЦПУ";
move 2;
B2: box wid 1 ht 1 "Сопроцессор";
#connetcions to upper buses
line <-> from 1/3 <B1.nw, B1.ne> to (1/3 <B1.nw, B1.ne>, L1) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .s at end of last line ;
line <-> from 2/3 <B1.nw, B1.ne> to (2/3 <B1.nw, B1.ne>, L2) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .s at end of last line ;
line <-> from 1/3 <B2.nw, B2.ne> to (1/3 <B2.nw, B2.ne>, L1) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .s at end of last line ;
line <-> from 2/3 <B2.nw, B2.ne> to (2/3 <B2.nw, B2.ne>, L2) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .s at end of last line ;
#lower buses
move to B1.sw + (0,-0.3);
L3: line 4 "шина флагов""";
move to L3.s + (0, -0.3);
L4: line 4 "шина прерываний""";
move to L4.s + (0, -0.3);
L5: line 4 "шина синхронизации""";
#connections to lower buses
line <-> from 1/4 <B2.sw, B2.se> to (1/4 <B2.sw, B2.se>, L3) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
line <-> from 2/4 <B2.sw, B2.se> to (2/4 <B2.sw, B2.se>, L4) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
line <-> from 3/4 <B2.sw, B2.se> to (3/4 <B2.sw, B2.se>, L5) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
line <-> from 1/4 <B1.sw, B1.se> to (1/4 <B1.sw, B1.se>, L3) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
line <-> from 2/4 <B1.sw, B1.se> to (2/4 <B1.sw, B1.se>, L4) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
line <-> from 3/4 <B1.sw, B1.se> to (3/4 <B1.sw, B1.se>, L5) chop 0 chop 0.03;
circle rad 0.03 fill 1 with .n at end of last line ;
move to L5 + (2, -0.25);
"Рисунок 6 \(em Общая схема соединения сопроцессора"
.PE
.KE
.
.H2 "Возможности применения"
.PP
Данное устройство, при снабжении его соответствующими интерфейсами,
может быть использовано для решения широкого круга задач.
.PP
Так, например, на его основе может быть построен потоковый шифратор для
шифрования тракта данных, выходящего за границу некой организации.
Для выполнения данной задачи, необходимо разработать два устройства, 
одно \(em для шифрования исходящего трафика, другое \(em 
для дешифрования принимаемого трафика, как показано на Рисунке 7
.PS
move 0.5;
box width 1.5 height 1.5 dashed "Организация Х""";
box wid 0.9 ht 0.5 with .se at last box.se + (-0.2, 0.2) "шифратор";
line right 3 "линия связи""";
box wid 0.9 ht 0.5  "дешифратор";
box width 1.5 height 1.5 dashed with .sw at last box.sw + (-0.2, -0.2)"Организация Y""";
move down 0.7 from last line.c;
"Рисунок 7 \(em Схема применения потокового шифратора"
.PE
.PP
Другой вариант применения \(em в составе устройства для 
шифрования данных носителей информации.
В случае применения такого устройства, 
данные носителя будут храниться в зашифрованном виде, 
нормальная работа с ними будет возможна лишь при наличии устройства.
Подобное решение может использоваться для 
защиты конфиденциальности информации, хранимой на носителе.
.PP
Рисунок 8 показывает схему применения такого устройства.
.KS
.PS
move right 2.4;
box wid 1.5 ht 0.5 "Носитель";
line down 1 aligned from last box.sw + (0.3, 0) -> "шифртекст""";
line down 1 aligned from last box.se + (-0.3, 0) <- "текст""";
box wid 1.5 ht 0.5 "Устройство" with .n at last box.s + (0, -1)
line down 1 aligned from last box.sw + (0.3, 0) -> "текст""";
line down 1 aligned from last box.se + (-0.3, 0) <- "шифртекст""";
box wid 1.5 ht 0.5 "ИС" with .n at last box.s + (0, -1)
move down 0.3;"Рисунок 8 \(em Схема применения устройства для шифрования данных носителей информации"
.PE
.KE
.PP
Стоит отметить, что в обоих случаях нагрузка по реализации ЗИ 
ложится на отдельное утройство, а не на систему обработки данных.
.PP
Как было отмечено ранее, данные варианты испоьзования показаны 
для примера, в реальности их может быть намного больше, 
причём для реализации нового решения, 
не придётся закупать полностью новое оборудование, 
можно лишь изменить программу или, при необходимости, 
изменить микроархитектуру устройства, ведь оно построено на базе ПЛИС. 
.
.
.
.
.H1 "РАЗРАБОТКА ЯДРА MIPS-ПОДОБНОГО ПРОЦЕССОРА НА ПЛИС"
.PP
Глваной задачей данной работы была создать ядро ЦПУ, 
на основе которого и будет выполняться средство ЗИ, 
основной архитектурой которого была выбрана архитектура MIPS. 
.PP
Компьютерная архитектура определяется набором 
команд и архитектурным состоянием. 
Архитектурное состояние процессора MIPS определяется содержимым 
счётчика команд (program counter) и 32 видимых программисту регистров,
поэтому любой процессор, реализующий архитектуру MIPS, 
вне зависимости от его микроархитектуры обязан иметь счётчик команд и 
ровно 32 регистра.
Зная текущее архитектурное состояние, процессор точно знает, 
какую операцию и над какими данными надо выполнить для получения нового
архитектурного состояния.
.PP
Рассмотрим структуру, показанную на Рисунке 9 и модуль верхнего уровня для разработанного процессорного ядра.
.KS
.PS 8 7.6
define mux { [
	sc = 0.2;
	L1: line  up sc * $1 / 2;
	line down sc * $1 / 3 right sc;
	L2: line down sc * $1 / 3;
	line down sc * $1 / 3 left sc;
	L3: line up sc * $1 / 2;
	O:line right sc from L2.center;
	move to L1.end + (0, -sc / 2);
	for i = 0 to ($1 - 1) do {
		C:line left sc;
		move down sc right sc;
	}
	]}
CPU: [	
move down 2 left 3;
Mux1: mux(3);
move to last [].O.end;
line right 0.4;
move to last line.center + (-0.1, 0.1);"pc_next";
move to last line.end;
right; box width 0.3 height 0.5 "\fBPC\fP";
line down 0.1 left 0.1 from last box.ne + (-0.05,0);
line up 0.1 left 0.1;
line up 0.2 from last box.n;
"clk" at end of last line + (0, 0.1);

PCout: line right 0.3 from last box.e;
circle rad 0.03 fill 1 with .center at .center of last line;
line down 1 from center of last line;
Adder1: [ line right 0.15 then down 0.3 left 0.3 then left 0.3 then left 0.3 up 0.3 then right 0.3 then right 0.15 down 0.15 then right 0.15 up 0.15 then right 0.15;] with .ne at last line.end + (0.15, 0);
"\fB+\fP" at Adder1.c + (0, -0.075);

line up 0.2 from Adder1.nw + (0.15,0); "1" at last line.end + (0, 0.1);
#line up 0.5 left 1 then up 1 then down 1 right 2 then down 1 then down 1 left 2 then up 1 then right 1 up 0.5;
L1: line down 2 from Adder1.s;
circle rad 0.03 fill 1 with .center at 1/4 <L1.start, L1.end>;
line to (Mux1.C.end, 1/4 <L1.start, L1.end>) from 1/4 <L1.start, L1.end>;
line to Mux1.C.end;
circle rad 0.03 fill 1 with .center at 2/4 <L1.start, L1.end>;
line left 0.3 from 2/4 <L1.start, L1.end>;

Adder2:[ line down 0.3 then left 0.15 down 0.15 then down 0.15 right 0.15 then down 0.3 then left 0.3 up 0.3 then up 0.3 then up 0.3 right 0.3] with .ne at last line.end + (0, 0.15);
"\fB+\fP" at Adder2.c + (-0.075, 0);
line from Adder2.w to (Mux1.C.end, Adder2) + (-0.1,0); 
Adder2_out: line to (last line.end, Mux1.C) + (0, 0.2);
line to Mux1.C + (0, 0.2);
move to PCout.r;right;

Instr_mem: [box width 1 height 1" " " " " \fBinstr_mem\fP";
"addr" at last box.nw + (0.2,-0.2);
"instr" at last box.nw + (0.8,-0.2);] with .nw at PCout.end + (0,0.2); 
line right 0.2 from Instr_mem.ne + (0,-0.2);

Instr: line down 3.3 aligned """""32-bit instruction";
line to (Adder2_out, Instr.end) + (-0.1, 0);
line to (last line.end, Mux1.C) + (0, 0.4);
line to Mux1.C + (0, 0.4);
circle rad 0.03 fill 1 with .center at Instr.start;
right;line 0.5 with .start at Instr.start "[25:21]""";

Reg_file: [box width 1.5 height 1.5 "\fBreg_file\fP";
"ra1" at last box.nw + (0.2,-0.2);
"ra2" at last box.nw + (0.2,-0.6);
"wa" at last box.nw + (0.2,-1);
"wd" at last box.nw + (0.2,-1.4);
"rd1" at last box.ne + (-0.2,-0.5);
"rd2" at last box.ne + (-0.2,-1);
"we" at last box.ne + (-0.2,-0.1);

line down 0.1 left 0.1 from last box.nw + (0.6,0);
line up 0.1 left 0.1;
line up 0.2 from last box.nw + (0.5,0);
"clk" at end of last line + (0, 0.1);
] with .nw at last line.end + (0,0.5);
line 0.5 with .start at Instr.start + (0, -0.4)"[20:16]""";
circle rad 0.03 fill 1 with .center at last line.start;

move to (Reg_file.c, Instr.c);
Mux2: mux(2);
right;
circle rad 0.03 fill 1 with .center at (Instr.c, Mux2.C) + (0, 0.2);
line to Mux2.C + (0, 0.2);
"[15:11]" at center of last line + (0, 0.1);
circle rad 0.03 fill 1 with .center at (Instr.c, Mux2.C);
line to Mux2.C ;
"[20:16]" at center of last line + (0, 0.1);
line from Mux2.O.end down 0.4 then left 1.6 ;
line to (last line.end, Reg_file.nw) + (0, -1);
line to Reg_file.nw + (0, -1);

circle rad 0.03 fill 1 with .center at Instr.start + (0, -2.5); 
line right 1 "[15:0]""";

Sign_ext: [box height 0.5 width 0.8 "\fBsign_ext\fP";]

move down 0.3 right 0.4 from Reg_file.ne + (-0.2, -1.5); 
Mux3: [line right 0.4 then down 0.2 left 0.4/3 then left 0.4/3 then left 0.4/3 up 0.2; ]
Rd2: line from Reg_file.ne + (0, -1.3) to (Mux3.nw, Reg_file.ne) + (0.3, -1.3);
line to Mux3.ne + (-0.1, 0);

Sign_ext_out: line from Sign_ext.e to (Mux3.nw, Sign_ext.w) + (-0.1, 0);
line to (last line.end, Mux3.n) + (0, 0.1);
line to (Mux3.nw, last line.end) + (0.1,0);
line down 0.1;

circle rad 0.03 fill 1 with .center at Sign_ext_out.end;
line to (last circle.c, Adder2.s) + (0, 0.15);
line to Adder2.se + (0, 0.15);

move to Mux3.se + (0.2, -0.3);
ALU: [ line right 0.2 then down 0.4 left 0.4 then left 0.4 then left 0.4 up 0.4 then right 0.4 then right 0.2 down 0.2 then right 0.2 up 0.2 then right 0.2;]
"\fBALU\fP" at ALU.c + (0, -0.1);
line from Mux3.s to ALU.nw + (0.2, 0);
line from Reg_file.ne + (0,-0.8) to (ALU.ne, Reg_file.ne) + (-0.2, -0.8);
line to ALU.ne + (-0.2, 0);
line down 0.3 from ALU.s + (-0.1, 0);

circle rad 0.03 fill 1 with .center at last line.c;
line left 0.5 from last circle.c;
ALU_out: line down 1.3;

move to 3rd last line.end + (0.3, 0);
RAM: [box width 1 height 1 "\fBdata_mem\fP";
"addr" at last box.nw + (0.2,-0.1);
"d_in" at last box.ne + (-0.2, -0.1);
"d_out" at last box.s + (0, 0.1);
"we" at last box.e + (-0.15, 0.2);
]
line down 0.1 left 0.1 from RAM.e + (0,-0.2);
line down 0.1 right 0.1;
line right 0.2 from RAM.e + (0, -0.3);
"clk" at end of last line + (0.15, 0);

circle rad 0.03 fill 1 with .center at Rd2.end;
line right 0.95 from last circle.c;
line to (last line.end, RAM.n);

move to RAM.s + (-0.3, -0.4);
Mux4: [line right 0.4 then down 0.2 left 0.4/3 then left 0.4/3 then left 0.4/3 up 0.2; ]
line from RAM.s down 0.3
line right 0.6 from ALU_out.end;
line down 0.14;

line from Mux4.s down 0.1;
line to (Reg_file.w, last line.end) + (-0.1, 0);
line to (last line.end, Reg_file.s) + (0, 0.1);
line right 0.1;

move to Mux1;
move up 2 right 3;
Contr: [box width 1 height 2.5 rad 0.1 "\fBcontroller\fP";
"func" at last box.nw + (0.2, -2.2);
"op_c" at last box.nw + (0.2, -1.8);
"zero" at last box.nw + (0.2, -0.5);
"pc_next_c" at last box.ne + (0.25, 0);
"result_c" at last box.ne + (0.25, 1 * -2.5 / 7);
"mw_c" at last box.ne + (0.25, 2 * -2.5 / 7);
"alu_c" at last box.ne + (0.25, 3 * -2.5 / 7);
"ArgB_c" at last box.ne + (0.25, 4 * -2.5 / 7);
"dest_reg_c" at last box.ne + (0.25, 5 * -2.5 / 7);
"we_c" at last box.ne + (0.25, 6 * -2.5 / 7);
]

#inputs to controller
#op_c
line from Instr.start to (Instr.start, Contr.n) + (0, -1.8);
circle rad 0.03 fill 1 with .center at last line.end;
line from last circle.c to Contr.nw + (0,-1.8) "[31:26]" "";
#func
circle rad 0.03 fill 1 with .center at 2nd last line.end + (0, -0.4);
line from last circle.c to Contr.nw + (0,-2.2) "[5:0]" "";
#zero
line down 0.15 from ALU.s + (0.1, 0) then right 0.6;
line to (last line.end, Contr.n) + (0, 0.3);
line to (Contr.w, last line.end) + (-0.2, 0);
line to (last line.end, Contr.nw) + (0, -0.6);
line to  Contr.nw + (0, -0.6);

#outputs from controller
#we_c
line from Contr.ne + (-0.22, 6.5 * -2.5 / 7) to (Reg_file.e,Contr.ne) + (-0.2, 6.5 * -2.5 / 7);
line to Reg_file.ne + (-0.2, -0.3);
#dest_reg_c
line from Contr.ne + (-0.22, 5.5 * -2.5 / 7) to (Reg_file.e,Contr.ne) + (0.05, 5.5 * -2.5 / 7);
line to (last line.end, Mux2.n);
line to Mux2.n;
line to Mux2.n + (0, -0.075);
#ArgB_c
line from Contr.ne + (-0.22, 4.5 * -2.5 / 7) to (Mux3.e, Contr.ne) + (0.05, 4.5 * -2.5 / 7);
line to (last line.end, Mux3.c);
line left 0.12;
#alu_c
line from Contr.ne + (-0.22, 3.5 * -2.5 / 7) to (ALU.e, Contr.ne) + (0.15, 3.5 * -2.5 / 7);
line to (last line.end, ALU.c);
line left 0.35;
#mw_c
line from Contr.ne + (-0.22, 2.5 * -2.5 / 7) to (RAM.e, Contr.ne) + (0.1, 2.5 * -2.5 / 7);
line to (last line.end, RAM.c) + (0, 0.2);
line left 0.1;
#result_c
line from Contr.ne + (-0.22, 1.5 * -2.5 / 7) to (RAM.e, Contr.ne) + (0.15, 1.5 * -2.5 / 7);
line to (last line.end, Mux4.c);
line left 0.6;
#pc_next_c
line right 0.3 from Contr.ne + (-0.22, 0.5 * -2.5 / 7);
line up 0.3
line to (Mux1.c, last line.end);
line to (last line.end, Mux1.n) + (0, -0.1);
]
"Рисунок 9 \(em CPU" at CPU.s + (0, -0.5);
.PE
.KE
.PP
В файле CPU.v описана общая структура ядра. 
.sp 0.5v
.in \n[PI]u
.nf
.ta T 2m
.vs -4p
.CW
module cpu (
	input wire clk,
	input wire reset,
	);
	
	wire [31:0] instr;
	wire [31:0]  A, B, rd2, C, s_imm, read_data, result; 
	wire [31:0] pc_next, pc_val, pc_inc, pc_br;
	wire [4:0] dest_reg;
	wire argB_c, dest_reg_c, we_c, result_c, mw_c, branch_c, zero;
	wire [3:0] alu_c; 

	PC		pc(.ctrl(clk), .reset(reset), .in(pc_next), .out(pc_val));

	rom2		rom_uut(.clk(clk), .addr(pc_val), .data(instr));

	adder		pc_incr(.A(32'h00000001), .B(pc_val), .C(pc_inc));

	adder		branch_add(.A(s_imm), .B(pc_inc), .C(pc_br));

	pc_val_mux	pc_mux(.ctrl(branch_c), .in0(pc_inc), 
	.in1(pc_br), .out(pc_next));

	sign_ext	s_e(.in(instr[15:0]), .out(s_imm));

	reg_file	r_f(.clk(clk),.we(we_c), .ra1(instr[25:21]), 
	.ra2(instr[20:16]), .wa(dest_reg), .rd1(A), .rd2(rd2),
	.wd(result) );
	
	mux2to1		#(.SIZE(5))mux21_dest(.in0(instr[15:11]), 
	.in1(instr[20:16]), .ctrl(dest_reg_c), .out(dest_reg));
	
	mux2to1		mux21_argB(.in0(rd2), .in1(s_imm), .ctrl(argB_c), 
	.out(B));
	
	alu 		alu_uut(.A(A), .B(B), .C(C), .mode(alu_c), .zero(zero));
	
	ram		data_mem(.clk(clk), .we(mw_c), .addr(C), 
	.d_in(rd2), .d_out(read_data));
	
	mux2to1		mux21_result(.in0(C), .in1(read_data), 
	.ctrl(result_c), .out(result));

	
	contr 		c_uut(.op_c(instr[31:26]), .funct(instr[5:0]), 
	.zero(zero), .argB_c(argB_c), .dest_reg_c(dest_reg_c), .we_c(we_c), 
	.result_c(result_c), .mw_c(mw_c), .branch_c(branch_c), 
	.alu_c(alu_c));

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл CPU.v\*P
.sp 1v
.PP
В структуре итогового процессорного ядра можно выделить 3 основных модуля:
.RS
.PI 1.
Регистровый файл;
.PI 2.
Арифметико-логическое устройство;
.PI 3.
Контроллер.
.RE
.PP
В рамках данной работы будут рассмотрены эти три модуля.
Файлы описания остальной части ядра приведены в приложении.
.PP
Файл reg_file.v содержит описание регистрового файла, 
хранящего все 32 видимых регистра.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 2m
.vs -4p
.CW
module reg_file(
	input wire clk,
	input wire we,//for write enable

	input wire [4:0] ra1,//
	input wire [4:0] ra2,//for read  addresses
	input wire [4:0] wa,//for write address
	
	output wire [31:0] rd1,// for read data
	output wire [31:0] rd2,//
	input wire [31:0] wd//for write data
);

localparam 
//registers
	zero = 5'b00000,

	at = 5'b00001,

	v0 = 5'b00010,
	v1 = 5'b00011,

	a0 = 5'b00100,
	a1 = 5'b00101,
	a2 = 5'b00110,
	a3 = 5'b00111,

	t0 = 5'b01000,
	t1 = 5'b01001,
	t2 = 5'b01010,
	t3 = 5'b01011,
	t4 = 5'b01100,
	t5 = 5'b01101,
	t6 = 5'b01110,
	t7 = 5'b01111,

	s0 = 5'b10000,
	s1 = 5'b10001,
	s2 = 5'b10010,
	s3 = 5'b10011,
	s4 = 5'b10100,
	s5 = 5'b10101,
	s6 = 5'b10110,
	s7 = 5'b10111,

	t8 = 5'b11000,
	t9 = 5'b11001,

	k0 = 5'b11010,
	k1 = 5'b11011,

	gp = 5'b11100,
	sp = 5'b11101,
	fp = 5'b11110,
	ra = 5'b11111;

	reg [31:0] rf [31:0];
	
	always @(posedge clk)
	if (we)
		rf[wa] <= wd;

	assign rd1 = (ra1 != 0) ? rf[ra1] : 0;
	assign rd2 = (ra2 != 0) ? rf[ra2] : 0;
endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл reg_file.v\*P
.sp 1v
.PP
Регистровый файл выполнен в виде блока RAM.
На вход поступают 3 адреса \(em два адреса 
регистров-источников операндов (\f(CWrd1, rd2\fP),
значения которых подаются на выходы \f(CWrd1, rd2\fP и 
один адрес регистра-назначения результата (\f(CWwa\fP), 
которому присваивается значение, поданое на вход \f(CWwd\fP, 
при условии, что был послан управляющий сигнал \f(CWwe\fP. 
.PP
Файл alu.v содержит описание АЛУ.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 2m
.vs -4p
.CW
module alu(
    input wire [3:0] mode,
    input wire [31:0] A,
    input wire [31:0] B,
    output reg [31:0] C,
    output reg zero
    );
	 
localparam
	 //functions
	 //logical
	 and_f = 4'b0000,
	 or_f = 4'b0001,
	 xor_f = 4'b0010,
	 nor_f = 4'b0011,
	 slt_f = 4'b0100,
	 nand_f = 4'b0101,
	 
	 //arithmetic
	 add_f = 4'b1000,
	 subtr_f = 4'b1001;
	 
	 always @ *
	 begin
	 zero = 0;
		case(mode)
		and_f:
			C = A & B;
		nand_f:
			C = ~(A & B);
		or_f:
			C = A | B;	
		xor_f:
			C = A ^ B;
		nor_f:
			C = ~(A | B);
		compl_f:
			C = -A;
		subtr_f:
			C = A - B;
		add_f:
			C = A + B;
		default:
			C = A;
		endcase
		
		if (C == 0)
				zero = 1'b1;
	 end

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл alu.v\*P
.sp 1v
.PP
На входы \f(CWA\fP и \f(CWB\fP подаются значения операндов, 
на вход \f(CWmode\fP  \(em код выполняемой инструкции, 
результат подаётся на выход \f(CWC\fP.
Стоит так же отметить наличие флага \f(CWzero\fP, 
выставляемого при равенстве результата нулю.
.PP
Файл contr.v содержит описание контроллера.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 2m
.vs -4p
.CW
module contr(
	input wire [5:0] op_c, 
	input wire [5:0] funct,
	input wire zero,
	output wire argB_c,
	output wire dest_reg_c,
	output wire we_c,
	output wire result_c,
	output wire mw_c,
	output wire branch_c,
	output wire [3:0] alu_c
	);
	wire [1:0] aluop;
	maindec		main_dec(.op_c(op_c), .argB_c(argB_c), 
	.dest_reg_c(dest_reg_c), .we_c(we_c), .result_c(result_c), 
	.mw_c(mw_c), .branch(branch), .aluop(aluop));
	aludec		alu_dec(.funct(funct), .aluop(aluop), 
	.alu_c(alu_c) );
	assign		branch_c = zero & branch;
endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл contr.v\*P
.sp 1.5v
.PP
Контроллер разделён на две части: основной декодер и декодер АЛУ.
Основной декодер преобразует код операции в управляющие сигналы.
Декодер АЛУ преобразует поле функции и сигнал \f(CWaluop\fP в управляющие сигналы АЛУ.
.H2 "Итог"
В рамках курсовой было создано ядро процессора с MIPS-подобной архитектурой. 
Данное ядро реализует лишь основные инструкции архитектуры MIPS, такие как арифметические и логические, функции перехода, общения с памятью.
И всё же устройство является полноценным однотактным процессором с 32-битным набором команд.
.
.
.
.U1 "ЗАКЛЮЧЕНИЕ"
.PP
В данной работе были выполнены все поставленные задачи.
.PP
Была рассмотрена  применимость ПЛИС и Hardware Description Language (HDL) для задач ЗИ. 
Резульатом было решение о том, что ПЛИС имеют ряд особенностей, делающих их мощным инструментом для решения задач ЗИ, в том числе и необычных. 
.PP
Была изучена архитектура MIPS и рассмотрены способы построения и пременения аппаратных средств КМЗИ на основе процессоров.
.PP
Была изучена архитектура MIPS;
.PP
Было разработано и описано процессорное ядро с MIPS-подобной архитектурой на языке Verilog.
.PP
Таким образом,на основании выполнения всех поставленных задач, цель данной работы можно считать полностью выполненной. В дальнейшем планируется  дополнение, расширение ядра и создание на его основе аппаратного устройства КМЗИ одним из вышеописанных способов, 
а так же снабжение его соответствующими интерфейсами. 
Данные задачи будут выполнятся в рамках ВКР.
.
.
.
.U1 "СПИСОК ИСПОЛЬЗОВАННЫХ ЛИТЕРАТУРЫ И ИСТОЧНИКОВ"
.RS
.PI 1)
David M. Harris and Sarah L. Harris. Digital Design and Computer Architecture. \(em1-е изд. \(em Boston:Morgan Kaufman, 2007 .\(em 570 c.
.PI 2)
P. Pal Chaudhuri. Computer organisation and design. \(em 3-е изд. \(em Delhi:PHI Learning, 2014. \(em 897 c.
.PI 3)
Самоделов А. Криптография в отдельном блоке: криптографический сопроцессор семейства STM32F4xx: 
[ Эдектронный ресурс ] // Официальный сайт компании "Компэл": URL: http://www.compel.ru/lib/ne/2012/6/4-kriptografiya-v-otdelnom-bloke-kriptograficheskiy-soprotsessor-semeystva-stm32f4xx. (дата обращения 03.12.2016).
.
.
.
.U1 "ПРИЛОЖЕНИЯ"
.
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \s+2\fB Приложение А\fP\s0 
.sp 0v
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \fB СПИСОК ФАЙЛОВ НА CD-ДИСКЕ\fP
.RS
.PI А.
 Spartan-3A/3AN FPGA Starter Kit Board User Guide.
.PI Б.
 Файл  adder.v
.PI В.
 Файл aludec.v
.PI Г.
 Файл alu.v
.PI Д.
 Файл contr.v
.PI Е.
 Файл cpu.v
.PI З.
 Файл maindec.v
.PI И. 
 Файл mux2to1.v
.PI К. 
 Файл PC.v
.PI Л. 
 Файл pc_val_mux.v
.PI Н. 
 Файл ram.v
.PI П. 
 Файл reg_file.v
.PI Р. 
 Файл instr_mem.v
.PI С. 
 Файл sign_ext.v
.RE
